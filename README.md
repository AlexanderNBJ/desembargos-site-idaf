# Portal de Cadastro de Deliberações de Desembargos - IDAF

## Requisitos
- Node 	(versão recomendada: >= 18.x)
- npm 	(vem com o Node, versão recomendada: >= 9.2.0)
- PostgreSQL (versão recomendada: 15.x)
- Extensão PostGIS instalada no PostgreSQL (versão recomendada: 3.3)

## Preparativos

1. Instalar as dependências do Node rodando o seguinte comando, estando na pasta `./backend`:
`npm install`
  

2. Adicionar o arquivo `.env` na pasta `./backend`, preenchendo-o com as informações relativas ao banco de dados, ao ambiente de execução do site, e à API de login. Siga conforme o exemplo a seguir e o arquivo em `./backend/.env.example`
```
# Dados para conexão com o banco de dados
DB_HOST=ipDoBancoDeDados
DB_PORT=portaDoBancoDeDados
DB_NAME=nomeDaDatabase
DB_USER=usuarioDoBancoDeDados
DB_PASS=senhaDoBancoDeDados

# Dados para acesso às tabelas do banco de dados
SCHEMA=schemaNoBancoDeDados
USER_TABLE=tabelaDeUsuariosNoBancoDeDados
DESEMBARGO_TABLE=tabelaDeDesembargosNoBancoDeDados
EMBARGO_TABLE=tabelaDeEmbargosNoBancoDeDados
EMBARGO_LEGACY_TABLE=tabelaDeEmbargosLegado
USER_LOG_TABLE=tabelaDeLogDeUsuarios

# Dados para utilização da API MappiaDB
MAPPIA_DB_URL=urlDaAPIMappiaDB
MAPPIA_IS_GERENTE_QUERY=requestDaAPIParaGerente
MAPPIA_IS_COMUM_QUERY=requestDaAPIParaComum

# Dados para a execução da aplicação
PORT=portaDaAplicacao
SECRET=senhaSecretDaAplicacao
```

3. A estrutura utilizada (em PostgreSQL) para as tabelas no BD nos ambientes de teste estão dispostas a seguir. Lembre-se de alterar `SCHEMA` para o schema definido no `.env`, bem como o nome das tabelas.


- Tabela de Usuários:

```
CREATE TABLE SCHEMA.USERS_TEST(
	USERNAME TEXT PRIMARY KEY,
	NAME TEXT,
	POSITION TEXT,
	CREATED_AT TIMESTAMPTZ DEFAULT NOW()
);
```

- Tabela de Desembargos:

```
CREATE TABLE IF NOT EXISTS SCHEMA.TESTE_DESEMBARGOS(
	ID BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
	NUMERO_ANO TEXT,
	NUMERO_EMBARGO TEXT,
	SERIE_EMBARGO CHAR,
	PROCESSO_SIMLAM TEXT,
	NUMERO_SEP BIGINT,
	NUMERO_EDOCS TEXT,
	COORDENADA_X NUMERIC,
	COORDENADA_Y NUMERIC,
	NOME_AUTUADO TEXT,
	AREA_DESEMBARGADA NUMERIC,
	TIPO_DESEMBARGO TEXT CHECK (tipo_desembargo IN ('TOTAL','PARCIAL','INDEFERIMENTO', 'DESINTERDIÇÃO')),
	DATA_DESEMBARGO DATE,
	RESPONSAVEL_DESEMBARGO TEXT NOT NULL REFERENCES SCHEMA.USERS_INFO(USERNAME),
	DESCRICAO TEXT,
	STATUS TEXT CHECK (status IN ('APROVADO','EM ANÁLISE','REVISÃO PENDENTE')),
	APROVADO_POR TEXT REFERENCES SCHEMA.USERS_INFO(USERNAME),
	FONTE_DADO TEXT DEFAULT 'SITE',
  DATA_EMBARGO DATE,
  AREA_EMBARGADA NUMERIC
);
```
  
- Tabela de Log de Usuários:
```
CREATE TABLE SCHEMA.LOG_TESTE(
	ID BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
	USERNAME TEXT NOT NULL,
	ACTION TEXT,
	DETAILS JSONB,
	IP INET,
	USER_AGENT TEXT,
	CREATED_AT TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

- Tabela de Embargos SIMLAM:

```
CREATE TABLE SCHEMA.EMBARGOS_SIMLAM_TESTE(
  PROCESSO TEXT,
	N_UIF_EMB TEXT,
  SERIE TEXT,
	NORTHING NUMERIC,
	EASTING NUMERIC,  
	NUMERO_SEP TEXT,
  NUMERO_EDOCS TEXT,
  AREA NUMERIC,
  DATA_EMBARGO DATE
);
```

- Tabela de Embargos SEP:

```
CREATE TABLE SCHEMA.EMBARGOS_SEP_TESTE(
	N_UIF_EMB TEXT,
  SERIE TEXT,
  NUMERO_SEP NUMERIC,
  NORTHING NUMERIC,
  EASTING NUMERIC,
  DATA_EMBARGO DATE,
  AREA NUMERIC,
  PRODUTO TEXT,
  NOME_AUTUADO TEXT
);
```

- Tabela de Registro Sequencial separado por Ano:
```
CREATE TABLE IF NOT EXISTS SCHEMA.DESEMBARGO_ANO_SEQ (
  ano INTEGER PRIMARY KEY,
  last_seq INTEGER NOT NULL DEFAULT 0
);
```
- Essa tabela existe para que, sempre que um desembargo for criado, associar ao campo `numero_ano` dele um número incremental único concatenado ao ano corrente.

### Script para criação do Trigger que preenche o `numero_ano` a cada inserção de desembargo

```
-- cria a função auxiliar
CREATE OR REPLACE FUNCTION SCHEMA.gen_numero_ano_if_null()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  v_year INTEGER := EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER;
  v_last INTEGER;
  v_newseq INTEGER;
BEGIN
  -- se já vier com numero_ano preenchido, não mexe
  IF NEW.numero_ano IS NOT NULL AND trim(NEW.numero_ano) <> '' THEN
    RETURN NEW;
  END IF;

  -- bloqueia a linha do ano (ou detecta que não existe)
  SELECT last_seq INTO v_last
  FROM SCHEMA.DESEMBARGO_ANO_SEQ
  WHERE ano = v_year
  FOR UPDATE;

  IF NOT FOUND THEN
    v_newseq := 1;
    INSERT INTO SCHEMA.DESEMBARGO_ANO_SEQ(ano, last_seq) VALUES (v_year, v_newseq);
  ELSE
    v_newseq := v_last + 1;
    UPDATE SCHEMA.DESEMBARGO_ANO_SEQ SET last_seq = v_newseq WHERE ano = v_year;
  END IF;

  -- atribui "N-YYYY" — N sem zero-padding. Troque aqui para lpad(v_newseq::text,3,'0') se quiser padding.
  NEW.numero_ano := v_newseq::text || '-' || v_year::text;

  RETURN NEW;
END;
$$;

-- trigger que executa antes do insert que chama a função para cada linha
DROP TRIGGER IF EXISTS trg_gen_numero_ano_if_null ON SCHEMA.desembargos_teste;
CREATE TRIGGER trg_gen_numero_ano_if_null
BEFORE INSERT ON SCHEMA.desembargos_teste
FOR EACH ROW
EXECUTE FUNCTION SCHEMA.gen_numero_ano_if_null();
```

### Script para popular a tabela `SCHEMA.DESEMBARGO_ANO_SEQ`:
#### Isso deve ser executado apenas uma vez para obter a sequência com os dados obtidos

```
WITH extracted AS (
  SELECT
    -- somente linhas que têm numero_ano bem formados "N-YYYY" (N dígitos, YYYY ano)
    (split_part(numero_ano, '-', 2))::int AS ano,
    max( (split_part(numero_ano, '-', 1))::int ) AS max_n
  FROM SCHEMA.desembargos_teste
  WHERE numero_ano ~ '^\d+-\d{4}$'
  GROUP BY (split_part(numero_ano, '-', 2))::int
)
INSERT INTO SCHEMA.DESEMBARGO_ANO_SEQ (ano, last_seq)
SELECT ano, max_n FROM extracted
ON CONFLICT (ano) DO UPDATE
  SET last_seq = GREATEST(SCHEMA.DESEMBARGO_ANO_SEQ.last_seq, EXCLUDED.last_seq);
```

## Execução

Para executar o backend, basta estar na pasta `./backend` e executar o seguinte comando:
`npm start`

Note que o servidor será executado na porta definida no arquivo `.env`, e o acesso ao endereço `localhost:PORTA`, substituindo PORTA pelo valor definido no `.env`, redirecionará ao site.
